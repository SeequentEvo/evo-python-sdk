#  Copyright Â© 2025 Bentley Systems, Incorporated
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#      http://www.apache.org/licenses/LICENSE-2.0
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
"""
Task API
=============


    The Task API provides the ability to execute computation tasks in Evo that require variable, on-demand
    processing power. Building the Task API into your application can enable fast processing of long
    running, or resource intensive operations, without depending on the end user's physical hardware.

    Tasks are created, triggering a job to be executed asynchronously within a specific topic for your organization,
    and can be monitored throughout their execution lifecycle.

    For more information on using the Task API, see [Overview](/docs/guides/tasks), or the API
    references here.

This code is generated from the OpenAPI specification for Task API.
API version: 0.0.2
"""

from evo.common.connector import APIConnector
from evo.common.data import EmptyResponse, RequestMethod
from evo.common.utils import get_package_details

from ..models import *  # noqa: F403

__all__ = ["JobsApi"]


class JobsApi:
    """API client for the Jobs endpoint.

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.

    :param connector: Client for communicating with the API.
    """

    def __init__(self, connector: APIConnector):
        self.connector = connector

    async def cancel_job(
        self,
        org_id: str,
        topic: str,
        task: str,
        job_id: str,
        additional_headers: dict[str, str] | None = None,
        request_timeout: int | float | tuple[int | float, int | float] | None = None,
    ) -> EmptyResponse:
        """Cancel a specific job

        Cancels a specific job, identified by the organization ID, topic, task, and job ID. The job's status is updated to 'canceling' and the job is stopped.

        :param org_id: The organization identifier
            Format: `uuid`
            Example: `'org_id_example'`
        :param topic: The compute topic
            Example: `'topic_example'`
        :param task: The compute task
            Example: `'task_example'`
        :param job_id: The job identifier
            Format: `uuid`
            Example: `'job_id_example'`
        :param additional_headers: (optional) Additional headers to send with the request.
        :param request_timeout: (optional) Timeout setting for this request. If one number is provided, it will be the
            total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.

        :return: Returns the result object.

        :raise evo.common.exceptions.BadRequestException: If the server responds with HTTP status 400.
        :raise evo.common.exceptions.UnauthorizedException: If the server responds with HTTP status 401.
        :raise evo.common.exceptions.ForbiddenException: If the server responds with HTTP status 403.
        :raise evo.common.exceptions.NotFoundException: If the server responds with HTTP status 404.
        :raise evo.common.exceptions.BaseTypedError: If the server responds with any other HTTP status between
            400 and 599, and the body of the response contains a descriptive `type` parameter.
        :raise evo.common.exceptions.EvoAPIException: If the server responds with any other HTTP status between 400
            and 599, and the body of the response does not contain a `type` parameter.
        :raise evo.common.exceptions.UnknownResponseError: For other HTTP status codes with no corresponding response
            type in `response_types_map`.
        """  # noqa: E501
        # Prepare the path parameters.
        _path_params = {
            "org_id": org_id,
            "topic": topic,
            "task": task,
            "job_id": job_id,
        }

        # Prepare the header parameters.
        package_details = get_package_details(__name__)
        _header_params = {
            package_details["name"]: package_details["version"],
        }
        if additional_headers is not None:
            _header_params.update(additional_headers)

        # Define the collection formats.
        _collection_formats = {}

        _response_types_map = {
            "204": EmptyResponse,
        }

        return await self.connector.call_api(
            method=RequestMethod.DELETE,
            resource_path="/compute/orgs/{org_id}/{topic}/{task}/{job_id}",
            path_params=_path_params,
            header_params=_header_params,
            collection_formats=_collection_formats,
            response_types_map=_response_types_map,
            request_timeout=request_timeout,
        )

    async def get_job_results(
        self,
        org_id: str,
        topic: str,
        task: str,
        job_id: str,
        additional_headers: dict[str, str] | None = None,
        request_timeout: int | float | tuple[int | float, int | float] | None = None,
    ) -> CompletedJobResponse:  # noqa: F405
        """Retrieve the results of a specific job

        Gets the results of a specific job, identified by the organization ID, topic, task, and job ID. The job's status is returned in the response, along with either the results or an error object, depending on the status of the job. If the job is ongoing, the response includes links to the job's cancellation endpoint and detailed status endpoint.

        :param org_id: The organization identifier
            Format: `uuid`
            Example: `'org_id_example'`
        :param topic: The compute topic
            Example: `'topic_example'`
        :param task: The compute task
            Example: `'task_example'`
        :param job_id: The job identifier
            Format: `uuid`
            Example: `'job_id_example'`
        :param additional_headers: (optional) Additional headers to send with the request.
        :param request_timeout: (optional) Timeout setting for this request. If one number is provided, it will be the
            total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.

        :return: Returns the result object.

        :raise evo.common.exceptions.BadRequestException: If the server responds with HTTP status 400.
        :raise evo.common.exceptions.UnauthorizedException: If the server responds with HTTP status 401.
        :raise evo.common.exceptions.ForbiddenException: If the server responds with HTTP status 403.
        :raise evo.common.exceptions.NotFoundException: If the server responds with HTTP status 404.
        :raise evo.common.exceptions.BaseTypedError: If the server responds with any other HTTP status between
            400 and 599, and the body of the response contains a descriptive `type` parameter.
        :raise evo.common.exceptions.EvoAPIException: If the server responds with any other HTTP status between 400
            and 599, and the body of the response does not contain a `type` parameter.
        :raise evo.common.exceptions.UnknownResponseError: For other HTTP status codes with no corresponding response
            type in `response_types_map`.
        """  # noqa: E501
        # Prepare the path parameters.
        _path_params = {
            "org_id": org_id,
            "topic": topic,
            "task": task,
            "job_id": job_id,
        }

        # Prepare the header parameters.
        package_details = get_package_details(__name__)
        _header_params = {
            package_details["name"]: package_details["version"],
            "Accept": "application/json",
        }
        if additional_headers is not None:
            _header_params.update(additional_headers)

        # Define the collection formats.
        _collection_formats = {}

        _response_types_map = {
            "200": CompletedJobResponse,  # noqa: F405
            "202": OngoingJobResponse,  # noqa: F405
        }

        return await self.connector.call_api(
            method=RequestMethod.GET,
            resource_path="/compute/orgs/{org_id}/{topic}/{task}/{job_id}",
            path_params=_path_params,
            header_params=_header_params,
            collection_formats=_collection_formats,
            response_types_map=_response_types_map,
            request_timeout=request_timeout,
        )

    async def get_job_status(
        self,
        org_id: str,
        topic: str,
        task: str,
        job_id: str,
        additional_headers: dict[str, str] | None = None,
        request_timeout: int | float | tuple[int | float, int | float] | None = None,
    ) -> JobStatusResponse:  # noqa: F405
        """Retrieve the status of a specific job

        Gets the status of a specific job, identified by the organization ID, topic, task, and job ID. The job's status is returned in the response, along with a progress indicator, a message, and an error object, if applicable. If the job is ongoing, the response includes links to the job's cancellation endpoint.

        :param org_id: The organization identifier
            Format: `uuid`
            Example: `'org_id_example'`
        :param topic: The compute topic
            Example: `'topic_example'`
        :param task: The compute task
            Example: `'task_example'`
        :param job_id: The job identifier
            Format: `uuid`
            Example: `'job_id_example'`
        :param additional_headers: (optional) Additional headers to send with the request.
        :param request_timeout: (optional) Timeout setting for this request. If one number is provided, it will be the
            total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.

        :return: Returns the result object.

        :raise evo.common.exceptions.BadRequestException: If the server responds with HTTP status 400.
        :raise evo.common.exceptions.UnauthorizedException: If the server responds with HTTP status 401.
        :raise evo.common.exceptions.ForbiddenException: If the server responds with HTTP status 403.
        :raise evo.common.exceptions.NotFoundException: If the server responds with HTTP status 404.
        :raise evo.common.exceptions.BaseTypedError: If the server responds with any other HTTP status between
            400 and 599, and the body of the response contains a descriptive `type` parameter.
        :raise evo.common.exceptions.EvoAPIException: If the server responds with any other HTTP status between 400
            and 599, and the body of the response does not contain a `type` parameter.
        :raise evo.common.exceptions.UnknownResponseError: For other HTTP status codes with no corresponding response
            type in `response_types_map`.
        """  # noqa: E501
        # Prepare the path parameters.
        _path_params = {
            "org_id": org_id,
            "topic": topic,
            "task": task,
            "job_id": job_id,
        }

        # Prepare the header parameters.
        package_details = get_package_details(__name__)
        _header_params = {
            package_details["name"]: package_details["version"],
            "Accept": "application/json",
        }
        if additional_headers is not None:
            _header_params.update(additional_headers)

        # Define the collection formats.
        _collection_formats = {}

        _response_types_map = {
            "200": JobStatusResponse,  # noqa: F405
            "202": JobStatusResponse,  # noqa: F405
        }

        return await self.connector.call_api(
            method=RequestMethod.GET,
            resource_path="/compute/orgs/{org_id}/{topic}/{task}/{job_id}/status",
            path_params=_path_params,
            header_params=_header_params,
            collection_formats=_collection_formats,
            response_types_map=_response_types_map,
            request_timeout=request_timeout,
        )
